package info.kgeorgiy.ja.potekhin.implementor;

import info.kgeorgiy.java.advanced.implementor.Impler;
import info.kgeorgiy.java.advanced.implementor.ImplerException;
import info.kgeorgiy.java.advanced.implementor.JarImpler;

import javax.tools.JavaCompiler;
import javax.tools.ToolProvider;
import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.Executable;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.URISyntaxException;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.*;
import java.util.jar.Attributes;
import java.util.jar.JarOutputStream;
import java.util.jar.Manifest;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;

/**
 * Class implementor.
 */
public class Implementor implements Impler, JarImpler {

    /**
     * Checks if token is valid ({@code true}) or not ({@code false})
     * <p>
     * Token is valid if it isn't:
     *
     * <ul>
     * <li>Primitive</li>
     * <li>Array</li>
     * <li>Enum</li>
     * <li>Final modifier</li>
     * <li>Private modifier</li>
     * </ul>
     *
     * @param token provided token.
     * @return {@code true} if token is valid and {@code false} otherwise.
     */
    private boolean isValid(final Class<?> token) {
        final int modifiers = token.getModifiers();

        return !(token.isPrimitive() ||
                token.isArray() ||
                token == Enum.class || token.isEnum() ||
                Modifier.isFinal(modifiers) ||
                Modifier.isPrivate(modifiers)
        );
    }

    /**
     * Generates "package " + package name + ";" for provided {@link Class} token.
     *
     * @param token provided token.
     * @return generated package name.
     */
    private static String getPackage(final Class<?> token) {
        final Package tokenPackage = token.getPackage();

        return Objects.isNull(tokenPackage) ? "" :
                "package " + tokenPackage.getName() + ";" + System.lineSeparator();
    }

    /**
     * Generates class declaration with modifiers and extensions for provided {@link Class} token.
     *
     * @param token provided token.
     * @return generated class declaration.
     */
    private static String declareClass(final Class<?> token) {
        return "public class " +
                token.getSimpleName() + "Impl " +
                (token.isInterface() ? "implements " : "extends ") +
                token.getCanonicalName() + " {";
    }

    /**
     * Returns {@link List} of constructors generated for provided {@link Class} token.
     *
     * <p>Each constructor is generated by {@link Implementor#generateConstructor(Constructor)}.
     *
     * @param token provided token.
     * @return {@link List} of constructors' codes.
     * @throws ImplerException if no public or protected constructors are provided.
     */
    private static List<String> generateAllConstructors(final Class<?> token) throws ImplerException {
        if (token.isInterface()) {
            return Collections.emptyList();
        }
        final List<String> constructors = Arrays.stream(token.getDeclaredConstructors())
                .filter(constructor -> !Modifier.isPrivate(constructor.getModifiers()))
                .map(Implementor::generateConstructor).collect(Collectors.toList());
        if (constructors.isEmpty()) {
            throw new ImplerException("Public and protected constructors are absent");
        }
        return constructors;
    }

    /**
     * Wraps provided methods by {@link MethodWrapper}.
     *
     * @param methods given array of methods.
     * @return {@link Set} of {@link MethodWrapper}. Wrapped methods.
     */
    private static Set<MethodWrapper> wrapMethods(final Method[] methods) {
        return Arrays.stream(methods).map(MethodWrapper::new).collect(Collectors.toCollection(HashSet::new));
    }

    /**
     * Returns the {@link Set} of all the public and protected methods from parents of provided token wrapped by {@link MethodWrapper}
     *
     * @param token provided token.
     * @return set of parents' methods.
     */
    private static Set<MethodWrapper> parentMethods(final Class<?> token) {
        if (token == null) {
            return Collections.emptySet();
        }
        final Set<MethodWrapper> methods = wrapMethods(token.getMethods());
        methods.addAll(wrapMethods(token.getDeclaredMethods()));
        methods.addAll(parentMethods(token.getSuperclass()));
        return methods;
    }


    /**
     * Returns {@link List} of methods generated for provided {@link Class} token.
     *
     * <p>Each method is generated by {@link Implementor#generateMethod(Method)}.
     *
     * @param token provided token.
     * @return {@link List} of methods' codes.
     */
    private static List<String> generateAllMethods(final Class<?> token) {
        final Set<MethodWrapper> methods = parentMethods(token);

        return methods.stream().map(MethodWrapper::getMethod)
                .filter(m -> Modifier.isAbstract(m.getModifiers()))
                .map(Implementor::generateMethod)
                .collect(Collectors.toList());
    }

    /**
     * Generates opening of code section for the provided executable.
     *
     * @param exec provided executable.
     * @param name executable name.
     * @return line ending with "{" for executable.
     */
    private static String generateExec(final Executable exec, final String name) {
        return "public " + name + "(" + generateArgs(exec, true) + ") " +
                generateExceptions(exec) + "{";
    }

    /**
     * Returns thrown exceptions for the provided executable.
     *
     * @param exec provided executable.
     * @return thrown exceptions.
     */
    private static String generateExceptions(final Executable exec) {
        final Class<?>[] exceptions = exec.getExceptionTypes();
        return exceptions.length == 0 ? "" : "throws " + Arrays.stream(exceptions)
                .map(Class::getCanonicalName)
                .collect(Collectors.joining(", "));
    }

    /**
     * Generates code for provided {@link Constructor}.
     * <p>
     * Default values are chosen according to {@link Implementor#getDefaultValue(Class)}
     *
     * @param constructor provided
     * @return generated code.
     */
    private static String generateConstructor(final Constructor<?> constructor) {
        return "\t" + generateExec(constructor,
                constructor.getDeclaringClass().getSimpleName()
                        + "Impl") + System.lineSeparator() +
                "\t\tsuper(" + generateArgs(constructor, false) + ");" +
                System.lineSeparator()
                + "\t}";
    }


    /**
     * Generates code for arguments of provided executable.
     *
     * @param exec          provided executable.
     * @param isDeclaration boolean flag indicating if it's a declaration.
     * @return generated arguments' code.
     */
    private static String generateArgs(final Executable exec, final boolean isDeclaration) {
        return Arrays.stream(exec.getParameters())
                .map(parameter -> (isDeclaration ? parameter.getType().getCanonicalName() + " " : "") +
                        parameter.getName()).collect(Collectors.joining(", "));
    }

    /**
     * Generates code for provided {@link Method}.
     * <p>
     * Default values are chosen according to {@link Implementor#getDefaultValue(Class)}
     *
     * @param method provided
     * @return generated code.
     */
    private static String generateMethod(final Method method) {
        return "\t" + generateExec(method,
                method.getReturnType().getCanonicalName() + " " + method.getName())
                + System.lineSeparator() +
                "\t\treturn " + getDefaultValue(method.getReturnType()) + ";" +
                System.lineSeparator()
                + "\t}";
    }

    /**
     * Returns default value of provided type.
     *
     * <p>Default values:</p>
     * <ul>
     * <li>Reference type: "{@code null}"</li>
     * <li>Primitive boolean type: "{@code true}"</li>
     * <li>Primitive void type: "" (empty string)</li>
     * <li>Primitive numerical types: "{@code 0}" </li>
     * </ul>
     *
     * @param returnType provided type.
     * @return default value.
     */
    private static String getDefaultValue(final Class<?> returnType) {
        if (returnType.isPrimitive()) {
            if (returnType.equals(void.class)) {
                return "";
            } else if (returnType.equals(boolean.class)) {
                return "true";
            } else {
                return "0";
            }
        } else {
            return null;
        }
    }

    /**
     * Generates class' code with constructors ({@link Constructor}) and methods ({@link Method})
     *
     * @param token provided {@link Class} token.
     * @return generated class code.
     * @throws ImplerException if exception occurred during generation.
     */
    private static String generateCode(final Class<?> token) throws ImplerException {
        return String.join(System.lineSeparator(),
                getPackage(token),
                declareClass(token),
                String.join(System.lineSeparator() + System.lineSeparator(),
                        generateAllConstructors(token)),
                String.join(System.lineSeparator() + System.lineSeparator(),
                        generateAllMethods(token)),
                "}"
        );
    }

    /**
     * Generates code implementing class or interface by provided {@code token}.
     * <p>
     * Token should be valid {@link Implementor#isValid(Class)}.
     *
     * @param token type token to implement.
     * @param root  root directory.
     * @throws ImplerException if token is not supported or there is an I/O exception related to output file.
     */
    @Override
    public void implement(final Class<?> token, final Path root) throws ImplerException {
        if (isValid(token)) {
            final Path path = root
                    .resolve(token.getPackageName().replace('.',
                            File.separatorChar))
                    .resolve(token.getSimpleName() + "Impl.java");
            if (path.getParent() != null) {
                try {
                    Files.createDirectories(path.getParent());
                } catch (final IOException e) {
                    // :NOTE: Не всегда
                    throw new ImplerException("Could not create parent directories: "
                            + e.getMessage());
                }
            }
            try (final BufferedWriter writer = Files.newBufferedWriter(path)) {
                writer.write(toUnicode(generateCode(token)));
            } catch (final IOException e) {
                throw new ImplerException(String.format("Problems with output file: %s", e.getMessage()));
            }
        } else {
            throw new ImplerException("Invalid token" + token.getCanonicalName());
        }
    }

    /**
     * Builds unicode representation of {@link String}.
     *
     * @param s provided string.
     * @return unicode representation.
     */
    private String toUnicode(final String s) {
        return s.chars().mapToObj(c -> String.format("\\u%04X", c)).collect(Collectors.joining());
    }

    /**
     * Creates jar containing code implementation generated by {@link Implementor#implement(Class, Path)}
     * <p>
     * Each token should be valid {@link Implementor#isValid(Class)}.
     *
     * @param token   type token to implement.
     * @param jarFile target jar-file.
     * @throws ImplerException if token is not supported or I/O exception occurred.
     */
    @Override
    public void implementJar(final Class<?> token, final Path jarFile) throws ImplerException {
        if (isValid(token)) {
            if (jarFile.getParent() != null) {
                try {
                    Files.createDirectories(jarFile.getParent());
                    final Path path = Files.createTempDirectory(jarFile.toAbsolutePath().getParent(), "temp");
                    try {
                        implement(token, path);
                        compile(token, path);
                        generateManifest(token, path, jarFile);
                    } finally {
                        Files.walkFileTree(path, new DeleteFileVisitor());
                    }
                } catch (final IOException e) {
                    throw new ImplerException("Problems with jar file " + jarFile);
                }
            }
        }
    }

    /**
     * Compiles generated class to provided token by System Compiler ({@link ToolProvider#getSystemJavaCompiler()})
     *
     * @param token provided token.
     * @param path  provided path.
     * @throws ImplerException No java compiler provided/URI Exception/Compilation code not equal to 0
     */
    private void compile(final Class<?> token, final Path path) throws ImplerException {
        final JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();
        if (javaCompiler != null) {
            try {
                final Path classPath = Path.of(token.getProtectionDomain().getCodeSource().getLocation().toURI());
                final Path filePath = path.resolve(
                        Path.of(
                                token.getPackageName().replace('.', File.separatorChar),
                                token.getSimpleName() + "Impl.java"
                        )
                );
                final String[] args = {
                        filePath.toString(),
                        "-cp",
                        path + File.pathSeparator + classPath};
                if (javaCompiler.run(null, null, null, args) != 0) {
                    throw new ImplerException("Problems during compilation");
                }
            } catch (final URISyntaxException e) {
                throw new ImplerException("URI exception: " + e.getMessage());
            }
        } else {
            throw new ImplerException("No java compiler");
        }
    }

    /**
     * Generates manifest for provided token, path and jar file path.
     *
     * @param token   provided token.
     * @param path    temporary path.
     * @param jarFile jar file.
     * @throws ImplerException if exception occurred during writing via {@link JarOutputStream}
     */
    private void generateManifest(final Class<?> token, final Path path, final Path jarFile) throws ImplerException {
        final Manifest manifest = new Manifest();
        final Attributes attributes = manifest.getMainAttributes();

        attributes.put(Attributes.Name.MANIFEST_VERSION, "1.0");

        try (final JarOutputStream jarOutputStream = new JarOutputStream(Files.newOutputStream(jarFile), manifest)) {
            final String className =
                    token.getPackageName().replace('.', '/') + "/" +
                            token.getSimpleName() + "Impl.class";
            jarOutputStream.putNextEntry(new ZipEntry(className));
            Files.copy(Paths.get(path.toString(), className), jarOutputStream);
        } catch (final IOException e) {
            throw new ImplerException("Problems during writing to JarOutput" + e.getMessage());
        }
    }

    /**
     * {@link FileVisitor} for deleting directories.
     */
    private static class DeleteFileVisitor extends SimpleFileVisitor<Path> {
        @Override
        public FileVisitResult visitFile(final Path file, final BasicFileAttributes attrs) throws IOException {
            Files.delete(file);
            return FileVisitResult.CONTINUE;
        }

        @Override
        public FileVisitResult postVisitDirectory(final Path dir, final IOException exc) throws IOException {
            Files.delete(dir);
            return FileVisitResult.CONTINUE;
        }
    }

    /**
     * Point of entry to {@link Implementor}.
     *
     * <p>There should be two or three arguments. None of them should be null.
     * For three arguments starting with {@code -jar} runs {@link JarImpler#implementJar(Class, Path)}.
     *
     * @param args provided arguments.
     */
    public static void main(final String[] args) {
        if (args == null) {
            System.err.println("No arguments");
            return;
        }

        if (Arrays.stream(args).anyMatch(Objects::isNull)) {
            System.err.println("All arguments must not be null");
            return;
        }

        try {
            final Implementor implementor = new Implementor();
            if (args.length == 2) {
                implementor.implement(Class.forName(args[0]), Path.of(args[1]));
            } else if (args.length == 3 && args[0].equals("-jar")) {
                implementor.implementJar(Class.forName(args[1]), Path.of(args[2]));
            } else {
                System.err.println("Wrong command");
            }
        } catch (final InvalidPathException e) {
            System.err.println("Wrong path: " + e.getMessage());
        } catch (final ClassNotFoundException e) {
            System.err.println("Wrong class name: " + e.getMessage());
        } catch (final ImplerException e) {
            System.err.println("Problems with implementor: " + e.getMessage());
        }
    }


}

/**
 * MethodWrapper with equals and hashCode
 */
class MethodWrapper {

    /**
     * method
     */
    private final Method method;

    /**
     * Constructor with method.
     *
     * @param method initial method.
     */
    public MethodWrapper(final Method method) {
        this.method = method;
    }

    /**
     * Getter.
     *
     * @return method.
     */
    public Method getMethod() {
        return method;
    }

    /**
     * Comparing by:
     *
     * <ul>
     * <li>{@link Method#getReturnType()}</li>
     * <li>{@link Method#getName()}</li>
     * <li>{@link Method#getParameterTypes()}</li>
     * </ul>
     *
     * @param o object to compare with.
     * @return {@code true} if equal, {@code false} otherwise
     */
    @Override
    public boolean equals(final Object o) {
        if (this == o) {
            return true;
        }

        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        final MethodWrapper mw = (MethodWrapper) o;

        return Objects.equals(method.getReturnType(), mw.method.getReturnType()) &&
                method.getName().equals(mw.method.getName()) &&
                Arrays.equals(method.getParameterTypes(), mw.method.getParameterTypes());
    }

    /**
     * Creates hash by:
     *
     * <ul>
     * <li>{@link Method#getName()}</li>
     * <li>{@link Method#getReturnType()}</li>
     * <li>{@link Method#getParameterTypes()}</li>
     * </ul>
     *
     * @return hash code.
     */
    @Override
    public int hashCode() {
        return Objects.hash(method.getName(), method.getReturnType(), Arrays.hashCode(method.getParameterTypes()));
    }
}
